- Day3_homework 해설 중(advanced문제) _ nextLine과 nextInt는 혼용해서 사용하면 안된다고함


1. protected 접근 제한자(상속 내용)
 - 같은 패키지 내의 클래스나 상속받은 자식 클래스에서 사용할 수 있는 필드나 메소드를 선언할 때 사용
 - 접근 제한자의 범위
	public > protected > default > private
	- protected : 패키지 내 자식클래스까지 사용 가능
	- default : 같은 클래스 내에서 사용 가능
	- private : 접근 불가

ec----Tv클래스/SamsungTv클래스/_01_protected클래스 (protected 상속 내용 테스트)
ec2---Day04.protect 패키지 / errorOfProtected클래스(Day04패키지의 Tv클래스를 import해서 사용)

2. 오버로딩(Day2인가 Day3에서 잠깐 언급한적 있음)

 - 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 새롭게 생성

3. 오버라이딩(메소드 재정의)

 - 상속받은 자식클래스에서 부모클래스에 존재하는 메소드를 재정의
 - 부모 클래스의 메소드와 오버라이딩 될 메소드의 이름과 형태가 동일해야 된다.
 - 당연히 상속이 필수 조건

ec---- Calculator클래스/_02_overloading클래스 (부모클래스 오버라이딩, 사용)
ec2--- CalMinus클래스/_03_overriding 클래스 (부모클래스, 자식클래스 사용)

4. super 키워드
 - 상속받은 자식클래스 내에서 부모클래스에 접근할 때 사용
 - 자식클래스에서 부모클래스의 생성자나 메소드를 사용할 때 super 키워드 사용
 - 자식클래스의 생성자에는 부모클래스의 생성자가 포함되어 있음
 - super.부모생성자() 형태로 생략되어 있음 (Day03 숙제 강사님 답안에 생략돼있는거 주석으로 써준 화면이 스샷1)
ec----Car클래스 / SportsCar클래스 / _04_super 클래스
 - 오버라이딩으로 재정의 된 메소드에서 부모클래스의 원본 메소드를 사용하고 싶을 때 주로 사용한다.

ec2--- 연습문제 _05_superCalculator에 
          CalMinus클래스의 int chk; 이걸 활용해서)
	chk = 1일 때 덧셈 실행, 2일 때는 마이너스 연산 되도록 해보기
5. 다형성
 - 기본 성질은 동일하지만 각각의 객체의 특색있는 성질이나 동작을 가지는 성질
    ex) 티비  ----------------  가격
	      (동일한 속성)  전원 켜기
			전원 끄기

	         삼성티비 티비상속    ---------------------------  빅스비
				   (삼성티비만의 성질)      빅스비 켜기
						         빅스비 끄기

	         엘지티비 티비상속    ---------------------------  구글어시스턴스
				   (엘지티비만의 성질)      구글어시스턴스 켜기
						         구글어시스턴스 끄기

 - 프로그래밍에서의 다형성은 상속받은 부모클래스에서 공통되는 성질과 동작을 가지고
   자식클래스만의 고유의 성질과 동작을 만드는 행위

6. 상속에서의 타입 변환
 - 상속받은 자식 클래스는 본인의 형태도 가지면서 부모 클래스의 형태도 가지고 있기 때문에 
   부모 클래스로의 형변환이 가능하다.
 - 부모 클래스로 형변환을 한 경우 자식 클래스에 있는 필드나 메소드는 사용 불가능

ec----Phone클래스(this.나옴, this 자주 나오는데 뭔지 알아볼것) / SmartPhone 클래스 / _06_inheritTypeChange 클래스

7. 강제 타입변환
 -  부모객체가 자식객체의 형태로 변환 되는 것
 - 부모객체가 생성될 때 자식 객체가 삽입된 경우에만 강제 타입변환 가능

ec----_07_forceTypeChange(앞에 만든 Phone, SmartPhone 클래스 활용)

8. 객체 타입 확인
 - instanceof 라는 키워드를 사용하여 진행
 - 결과 값은 boolean값으로 리턴
 - boolean result = 타입을 확인할 객체의 이름 instanceof 클래스명

ec---- _08_instanceOf 클래스

9. 타입 변환의 사용 목적
 - 필드객체를 생성할 때 부모객체로 선언하게 되면 다양한 자식 객체들을 담을 수 있기 때문에
   많은 결과 값을 얻을 수 있다.

ec----Vihicle, Bus, Taxi, Driver, _09_reasonOfTypeChange 클래스
		**중요** 상속은 잘 알고 넘어가야 한다고함

10. 추상클래스
 - 여러 개의 클래스들의 공통된 필드랑 메소드만 모아서 관리하는 클래스
 - 삼성티비	--------------티비(추상클래스)--------------> 엘지티비
   삼성티비와 엘지티비에 공통된 필드와 메소드를 티비라는 추상 클래스로 관리한다.
 - 추상클래스와 일반 클래스는 상속 관계로 묶이게 됨
 - 추상클래스를 사용하는 이유
	공통으로 사용하는 변수명이나 메소드명을 통일할 수 있다.
	->공통되는 코드가 추상클래스에서 관리되기 때문에 소스코드 작성 시간을 줄일 수 있다.
 - 추상클래스의 선언은 abstract 키워드 사용
    public abstract 클래스명 {
    }


ec---- Phone, SmartPhone 클래스 수정해서 사용했고 _10_abstract 클래스 생성
	(Phone이 추상 클래스라고 했던거같음)

11. 추상메소드
 - 자식 객체에서 공통적으로 가지고 있는 메소드 중 서로 동작이 다른 메소드
 - 추상클래스 안에 추상메소드로 선언
 - 선언부만 추상클래스에 존재하고 자식클래스에서 정의한다.
 - 추상메소드는 자식클래스에서 반드시 구현되어야 함
 - 추상메소드를 포함하는 클래스는 반드시 추상클래스여야 함
ec----Animal클래스, Dog클래스

 - 추상클래스와 일반 클래스는 큰 차이는 없어 보이지만
   추상 메소드를 사용할 수 있기 때문에 사용한다고 볼 수 있다.
   추상메소드를 부모클래스에서 선언해놓으면 자식 클래스에서 추상메소드를 사용하지 않을 경우 오류가 발생한다(부모클래스에서 추상메소드가 선언만 되고 정의가 안 되었기 때문)
     -> 추상메소드 사용을 강제하기 위한 기능으로 사용된다고 볼 수 있다. (모든 자식클래스에서 부모클래스의 메소드가 사용 되도록
         (예를 들어 부모클래스(Animal)에서 소리를 낸다는 메소드를 선언하면 자식클래스(Dog, Cat)에서 소리를 내는 메소드를 정의 해야만 오류가 발생하지 않는다.
ec----_11_abStractMethod 클래스